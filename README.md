# Практика с RabbitMQ

В рамках данного задания вы научитесь работать с брокером сообщений [RabbitMQ](https://rabbitmq.com/getstarted.html). Вам предстоит реализовать сервис для генерации описания к изображениям. Пользователь может загрузить изображение, после чего ваш сервис должен будет сгенерировать описание к изображению, сохранить результат обработки в файл и вернуть описание пользователю по запросу.

## Архитектура и интерфейс сервиса

Часто очереди сообщений используются для того, чтобы избежать немедленного выполнения ресурсоемкой задачи и ожидания её завершения. Вместо этого мы передаем задачу для асинхронной обработки другому компоненту. Например, данный паттерн часто применяется для работы с видео. В нашем сервисе также можно выделить компонент, который будет заниматься подобной работой (генерацией описаний), назовем его воркер.

При реализации сервиса можно было бы использовать прямое взаимодействие между REST API и воркером. Однако использование очереди дает такие преимущества, как обработка отказов (если воркер упадет, то запрос не будет потерян и будет в конце концов обработан), поглощение всплесков нагрузки (если пришло много запросов, они не свалятся сразу все на воркера) и возможность горизонтально масштабировать обработку запросов (мы можем держать несколько воркеров, изменяя их количество в зависимости от нагрузки и используя очередь для распределения работы).

Исходя из этого, мы будем использовать следующую архитектуру для нашего сервиса:

![Architecture](media/architecture.png)

1. Сервер с REST API принимает и обрабатывает запросы от пользователей. Запросы на генерацию описаний передаются в виде сообщений в очередь RabbitMQ.
2. Воркеры забирают сообщения из очереди, генерируют требуемые описания и записывают их в общее хранилище, откуда их может прочитать REST API (в нашем случае это будет [Docker volume](https://docs.docker.com/engine/storage/volumes/), см. [docker-compose.yml](docker-compose.yml)).

Мы будем использовать **RabbitMQ версии 3**. Обратите внимание, что тесты поднимают брокер именно этой версии, поэтому в реализации сервиса не стоит использовать новый функционал из версии 4.

### REST API

Сервис будет поддерживать следующие типы запросов (формат везде JSON):

```
POST /api/v1.0/images
Отправляет изображение (URL) для обработки и возвращает его id. 
Возвращаемые id не обязаны быть последовательными, но обязаны быть уникальными.

Тело запроса:
{
    "image_url": str
}

Тело ответа:
{
    "image_id": int
}
```

```
GET /api/v1.0/images
Возвращает id всех обработанных изображений.

Тело ответа:
{
    "image_ids": List[int]
}
```

```
GET /api/v1.0/images/<image_id>
Возвращает описание для данного изображения, если оно уже было обработано, 
и код 404 в противном случае.

Тело ответа:
{
    "caption": str
}
```

## Компоненты задания и оценивание

1. **(4 балла)** Реализована корректная обработка всех запросов к REST API. Запросы на генерацию описаний передаются в очередь RabbitMQ и успешно обрабатываются воркерами в отсутствии отказов. Проходят все тесты из группы `BASIC`.
2. **(2 балла)** В дополнение к пункту 1 через RabbitMQ реализовано уведомление сервера об обработке изображения воркером. То есть серверу не требуется следить за файлами в общей директории, и он может правильно отвечать на запрос `GET .../images` без чтения списка файлов в директории. Передавать в уведомлениях описания изображений не нужно. Проходят все тесты из группы `CALLBACKS`.
3. **(4 балла)** Гарантируется обработка запросов в условиях отказов воркеров, RabbitMQ и сети. То есть каждый принятый (ответили 200) запрос клиента должен быть в конце концов обработан, и клиенту должно быть передано сгенерированное описание. Проходят тесты из групп `FAULT_TOLERANCE_(1-4)`, за каждую группу дается 1 балл. В отчёте надо обосновать почему ваша реализация гарантирует обработку.
4. Отчёт в файле `solution/readme.md` с описанием структуры решения и важных деталей реализации. **При отсутствии отчёта проверка производиться не будет.**

## Заготовки для решения

В папке `solution/server` находится заготовка для сервера с реализацией REST API на Flask.

В папке `solution/worker` содержится заготовка для воркера. В качестве логики обработки изображений надо использовать функцию `produce_image_caption`.

Для взаимодействия с RabbitMQ на Python предлагается использовать библиотеку [Pika](https://github.com/pika/pika) (см. семинар 5).

Весь код решения должен размещаться в папке `solution`. При сдаче решения в тестирующую систему отправляется только эта папка, изменения вне неё учитываться не будут.

## Порядок выполнения задания

1. Перед тем как приступать к выполнению задания, посмотрите материалы семинара 5. Также при выполнении задания будут полезны официальные [туториалы](https://www.rabbitmq.com/tutorials#queue-tutorials).
1. Реализуйте логику обработки запроса и отправки сообщения в очередь на стороне сервера (метод `add_image`). **Важный момент:** очередь должна называться `task_queue`, это имя используется в тестах.
2. Реализуйте логику чтения сообщений из очереди и их обработки в воркере. Добавьте сохранение результата обработки в файл `/data/{image_id}.txt`.
3. Реализуйте на стороне сервера методы `get_processed_images` и `get_image_caption` через чтение содержимого директории `/data`.
4. Пункт 1 должен быть готов, проверьте что локально проходят все тесты из группы `BASIC`. При необходимости поправьте `Dockerfile` для ваших сервера и воркера.
5. Модифицируйте метод `get_processed_images` на стороне сервера так, чтобы он больше не обращался к хранилищу, а получал id обработанных сообщений от воркеров через дополнительную очередь. Почитайте [туториал](https://www.rabbitmq.com/tutorials/tutorial-six-python.html) и **не забывайте о потокобезопасности**. Проверьте что проходят тесты из группы `CALLBACKS`, пункт 2 готов.
6. Работу над пунктом 3 начните с теста `test_heartbeats_timeout`. Изучите [документацию](https://www.rabbitmq.com/docs/heartbeats), посмотрите какое значение `heartbeat` используется в тестах (см. [rabbitmq.conf](tests/rabbitmq.conf)). При использовании `BlockingConnection` полезно почитать [это обсуждение](https://github.com/pika/pika/discussions/1382).
7. Подумайте в каких случаях ваша реализация может терять запросы. Изучите предоставляемые RabbitMQ [механизмы](https://www.rabbitmq.com/docs/3.13/confirms) для реализации надежной доставки (см. также [этот пример](https://github.com/pika/pika/blob/main/examples/asynchronous_publisher_example.py)).
8. Защититесь от потерь сообщений между сервером и RabbitMQ c помощью механизма publisher confirms. Проверьте, что проходит тест `test_publisher_confirms`.
9. Защититесь от отказов воркеров и потерь сообщений между ними и RabbitMQ с помощью механизма consumer acknowledgements. Проверьте, что проходят тесты `test_faulty_worker` и `test_two_faulty_workers`.
10. Защититесь от падений и рестартов RabbitMQ с помощью механизма durable queues. Проверьте, что проходит тест `test_faulty_worker_and_rabbit_restart`.
11. Остался тест `test_total_eclipse_of_the_heart`. Если остальные тесты пройдены, то скорее всего он тоже пройдет. Полезное упражнение на подумать - какой результат будет, если в конце этого теста RabbitMQ так и не поднимется. Также полезно подумать о том, какие другие отказы остались не покрыты в вашей реализации.
12. Подготовьте отчёт с описанием вашего решения в `solution/readme.md`. Обязательно укажите, какие компоненты были выполнены. Для пункта 3 (отказоустойчивость) добавьте обоснование.
13. Сдайте решение с отчётом в тестирующую систему.

## Тестирование решения

Тесты, проверяющие решение, находятся в папке `tests`.

Если вы найдете ошибки или требования из условий, которые не покрывают наши тесты, то вы можете получить за это бонусные баллы. Подробности [здесь](https://forms.gle/GngHr4jWweEKrf4M6).

### Локальное тестирование

Для локального запуска тестов установите зависимости из `tests/requirements.txt`.

Перед запуском тестов не забудьте обновить образы сервера и воркера:

```
docker compose build server worker
```

Запуск всех тестов выполняется с помощью команды:

```
python3 tests/main.py
```

Отдельный тест можно запустить так:

```
pytest -vs --tb=short tests/test_server.py::test_single_image
```

Для тестирования также можно использовать команду `python3 ../cli.py test`. В этом случае используемое окружение будет аналогично тестирующей системе.

### Проверка в тестирующей системе

Отправьте ваше решение в тестирующую систему следуя [инструкции](../readme.md) и дождитесь результатов.

## ЧаВо

**Можно ли реализовать решение не на Python?**

Да. Просто выкиньте заготовки и напишите свои Dockerfile для сервера и воркера.

**Можно ли обрабатывать изображения локально на сервере?**

Нет. Описания к изображениям должны генерироваться только воркерами. В этом весь смысл этого задания. Если вы генерируете их на сервере, то такое решение не будет принято (0 баллов).
