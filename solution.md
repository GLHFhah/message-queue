Начнем с реализации server.py

Инициализация создает структуры данных для хранения состояния, дожидается и устанавливает соединение с RabbitMQ, отчищая очередь (иначе бы
не проходил один из тестов BASIC), запускает фоновые потоки для callback-ов и буфферизации. Заметим, что и в callbacke и в буфферизации и
в попытке отправить сообщение сразу мы будем подключаться к RabbitMQ заново для обеспечения потокобезопасности и отказоустойчивости.

_buffer_publisher_loop:
    Отправляет сообщения из буфера при восстановлении связи с RabbitMQ, если не получилось - обратно добавляет в буффер.

_callback_loop
    Непрерывно слушает очередь "callback_queue", при получении сообщения пытается потокобезопасно обновить состояние (добавляет в сет
    processed_images)
    При успешной обработке - отправляем ack, иначе nack и добавляем сообщение обратно в callback_queue.

_try_publish_immediately
    По сути отправляет сообщения тем же образом, что и _buffer_publisher_loop, но делает это без добавления в буффер, а сразу, что разгружает
    нашу систему.

add_image
    Добавляем сообщение в обработку, пытаемся отправить сразу, если не получается (что-то отказало) - добавляем в буффер и уведомляем об этом
    поток буфферизации

Все остальное в решении по сути пояснять не надо, шаблонное приведение обработанных сообщений к списку и шаблонное получение описания к
image

Теперь worker.py

В инициализации делаем то же самое, что и в server.py

process_message
    При получении сообщения пытаемся его обработать (с помощью produce_image_caption). Если получается - отсылаем ack. Иначе nack и обратно
    добавляем в очередь "task_queue".

send_callback
    Отправляем уведомления - оповещаем сервер о том, что обработка image_id завершена, если не получилось (в основном - не получается подклю-
    читься к rabbitMQ) - повторяем эти действия

run
    бесконечный цикл потребления сообщений (чтобы при отказах воркер обратно подключался к rabbitMQ)


Теперь поясним отказоустойчивость. Как уже написал выше - всегла пытаемся заново подключиться к rabbitMQ, всегда
пересоздаем очередь, не забываем ее отчистить изначально. Все очереди делаем durable=True, чтобы они не отчищались сами при переподключениях.
Сюда же можно прибавить логику ack-nack с добавлением сообщений обратно в очередь.
Не забываем также про basic_qos(prefetch_count=1), чтобы не отдавать воркеру больше одного сообщения за раз, чтобы при его падении
терялось только одно сообщения, которое мы можем вернуть в начало очереди, а не много сразу
